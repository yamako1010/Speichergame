const EMOJIS = ["üçé", "üê±", "üå∏", "‚≠ê", "üê∂", "üçã", "üçì", "‚ö°"];
const SHOW_DURATION_MS = 5000;
const MEMORIZE_DURATION_SECONDS = SHOW_DURATION_MS / 1000;
const SELECTION_DURATION_SECONDS = 10;
const BASE_CARD_COUNT = 3;
const BEST_SCORE_KEY = "memoryAdventureBest";
const MAX_MISTAKES = 1;
const DIFFICULTY_CONFIG = {
  easy: { size: 3 },
  medium: { size: 5 },
  hard: { size: 7 }
};
const RANK_TABLE = {
  easy: {
    label: "ÂàùÁ¥ö",
    world: "Êùë„ÅÆÂÜíÈô∫ËÄÖË¶ãÁøí„ÅÑ",
    titles: ["„Åº„Çì„ÇÑ„ÇäÊùë‰∫∫", "Ë¶ãÁøí„ÅÑÂÜíÈô∫ËÄÖ", "Â∞è„Åï„Å™ÂãáËÄÖ", "Êùë„ÅÆËã±ÈõÑ", "Â§©ÊâçÂãáËÄÖ"]
  },
  medium: {
    label: "‰∏≠Á¥ö",
    world: "Âüé‰∏ãÁî∫„ÇÑÊ£Æ„ÅÆË©¶Á∑¥",
    titles: ["ÊóÖ„ÅÆÊåëÊà¶ËÄÖ", "Ê£Æ„ÅÆÊé¢Ê§úÂÆ∂", "ÁéãÂõΩ„ÅÆÊà¶Â£´", "Ë®òÊÜ∂„ÅÆÈ®éÂ£´", "„Çπ„Éº„Éë„ÉºÂãáËÄÖ"]
  },
  hard: {
    label: "‰∏äÁ¥ö",
    world: "‰ºùË™¨„ÅÆÁ•ûÊÆø",
    titles: ["ÁÑ°Ë¨Ä„Å™ÊåëÊà¶ËÄÖ", "Ë®òÊÜ∂ÂøçËÄÖ", "Ë≥¢ËÄÖ", "Ë®òÊÜ∂„ÅÆÁéã", "Ë®òÊÜ∂Á•û"]
  }
};

const cardList = document.getElementById("card-list");
const messageEl = document.getElementById("message");
const currentLevelEl = document.getElementById("current-level");
const bestScoreEl = document.getElementById("best-score");
const countdownValueEl = document.getElementById("countdown-value");
const countdownCircle = document.querySelector(".countdown-circle");
const restartBtn = document.getElementById("restart-btn");
const endGameBtn = document.getElementById("end-game-btn");
const choicesContainer = document.querySelector(".choices");
const selectionList = document.getElementById("selection-list");
const difficultySelect = document.getElementById("difficulty-select");
const statusPopup = document.getElementById("status-popup");
const statusText = statusPopup ? statusPopup.querySelector(".status-text") : null;
const statusActions = statusPopup ? document.getElementById("status-actions") : null;
const startOverlay = document.getElementById("start-overlay");
const startBtn = document.getElementById("start-btn");

let currentLevel = 1;
let bestScore = 0;
let cardSequence = [];
let remainingAnswers = [];
let countdownIntervalId = null;
let acceptingGuesses = false;
let playerSelections = [];
let countdownRemaining = MEMORIZE_DURATION_SECONDS;
let selectedDifficulty = difficultySelect ? difficultySelect.value : "easy";
let choiceButtons = [];
let mistakesLeft = MAX_MISTAKES;
let countdownWarningThreshold = 2;
let countdownCompleteCallback = null;

function init() {
  loadBestScore();
  attachEventListeners();
  showStartOverlay();
}

function loadBestScore() {
  const stored = localStorage.getItem(BEST_SCORE_KEY);
  bestScore = stored ? Number(stored) : 0;
  if (Number.isNaN(bestScore)) {
    bestScore = 0;
  }
  updateBestScoreDisplay();
}

function attachEventListeners() {
  if (difficultySelect) {
    difficultySelect.addEventListener("change", (event) => {
      selectedDifficulty = event.target.value;
      startGame();
    });
  }

  restartBtn.addEventListener("click", () => {
    returnToStartScreen();
  });

  if (endGameBtn) {
    endGameBtn.addEventListener("click", () => {
      endGameManually();
    });
  }

  if (startBtn) {
    startBtn.addEventListener("click", () => {
      startGame();
    });
  }
}

function startGame() {
  currentLevel = 1;
  restartBtn.classList.add("hidden");
  messageEl.textContent = "";
  if (difficultySelect) {
    difficultySelect.value = selectedDifficulty;
  }
  stopCountdown();
  setFeedback("neutral");
  hideStatusPopup();
  hideStartOverlay();
  beginLevel();
}

function beginLevel() {
  stopCountdown();
  acceptingGuesses = false;
  renderChoices();
  setChoicesEnabled(false);
  mistakesLeft = MAX_MISTAKES;
  setFeedback("neutral");
  hideStatusPopup();

  updateCurrentLevelDisplay();
  maybeUpdateBestScore();

  cardSequence = generateSequenceForLevel(currentLevel);
  remainingAnswers = cardSequence.slice();
  resetSelectionHistory();

  renderCards(cardSequence);
  setMessage("„Ç´„Éº„Éâ„ÇíË¶ö„Åà„Å¶„Åè„Å†„Åï„ÅÑ‚Ä¶", "info");
  startMemorizeCountdown();
}

function generateSequenceForLevel(level) {
  const count = BASE_CARD_COUNT + level - 1;
  const pool = getActiveEmojiPool();
  const sequence = [];
  for (let i = 0; i < count; i += 1) {
    const emoji = pool[Math.floor(Math.random() * pool.length)];
    sequence.push(emoji);
  }
  return sequence;
}

function renderCards(cards) {
  cardList.innerHTML = "";
  cards.forEach((emoji) => {
    const card = document.createElement("div");
    card.className = "card";
    card.dataset.emoji = emoji;
    card.textContent = emoji;
    cardList.appendChild(card);
  });
}

function coverCards() {
  cardList.querySelectorAll(".card").forEach((card) => {
    card.classList.add("covered");
    card.setAttribute("aria-hidden", "true");
  });
}

function revealCards() {
  cardList.querySelectorAll(".card").forEach((card) => {
    card.classList.remove("covered");
    card.removeAttribute("aria-hidden");
  });
}

function handleChoice(selectedEmoji) {
  if (!acceptingGuesses) {
    return;
  }

  const clickedButton = choiceButtons.find((btn) => btn.dataset.emoji === selectedEmoji);
  playerSelections.push(selectedEmoji);
  renderSelectionHistory();

  const matchIndex = remainingAnswers.indexOf(selectedEmoji);

  if (matchIndex === -1) {
    handleIncorrectSelection(selectedEmoji);
    return;
  }

  remainingAnswers.splice(matchIndex, 1);
  if (clickedButton) {
    clickedButton.dataset.result = "‚óé";
    clickedButton.classList.add("choice-success");
    clickedButton.classList.remove("choice-fail");
  }
  setFeedback("success");

  if (remainingAnswers.length === 0) {
    stopCountdown();
    acceptingGuesses = false;
    setChoicesEnabled(false);
    setMessage("Ê≠£Ëß£ÔºÅÊ¨°„ÅÆ„É¨„Éô„É´„Å∏ÈÄ≤„Åø„Åæ„Åô„ÄÇ", "success");
    showStatusPopup("success", "Ê≠£Ëß£ÔºÅÔºÅ");
    window.setTimeout(() => {
      currentLevel += 1;
      beginLevel();
    }, 1200);
  } else {
    setMessage(`Ê≠£Ëß£ÔºÅ„ÅÇ„Å®${remainingAnswers.length}Êûö„ÄÇ`, "success");
  }
}

function handleGameOver(selectedEmoji, options = {}) {
  stopCountdown();
  updateCountdownDisplay(0);
  acceptingGuesses = false;
  setChoicesEnabled(false);
  revealCards();

  const failureMessage = options.messageOverride
    ? options.messageOverride
    : `ÊÆãÂøµÔºÅ ${selectedEmoji} „ÅØË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ`;
  setMessage(failureMessage, "error");
  setFeedback("error");
  if (options.popupType) {
    showStatusPopup(options.popupType, options.popupMessage || failureMessage, options.actions);
  } else {
    showStatusPopup("fail", "ÊÆãÂøµÔºÅ", [
      {
        label: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶„Åô„Çã",
        className: "restart",
        onClick: () => returnToStartScreen()
      }
    ]);
  }
  restartBtn.classList.remove("hidden");
}

function setChoicesEnabled(isEnabled) {
  choiceButtons.forEach((button) => {
    button.disabled = !isEnabled;
  });
}

function setMessage(text) {
  messageEl.textContent = text;
}

function updateCurrentLevelDisplay() {
  currentLevelEl.textContent = currentLevel;
}

function maybeUpdateBestScore() {
  if (currentLevel > bestScore) {
    bestScore = currentLevel;
    updateBestScoreDisplay();
    persistBestScore();
  }
}

function updateBestScoreDisplay() {
  bestScoreEl.textContent = bestScore;
}

function startMemorizeCountdown() {
  startCountdown(MEMORIZE_DURATION_SECONDS, "memorize", () => {
    coverCards();
    acceptingGuesses = true;
    setChoicesEnabled(true);
    setMessage(`Ë°®Á§∫„Åï„Çå„ÅüÁµµÊñáÂ≠ó„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑÔºÅÔºàÂà∂ÈôêÊôÇÈñì${SELECTION_DURATION_SECONDS}ÁßíÔºâ`, "info");
    startSelectionCountdown();
  });
}

function startSelectionCountdown() {
  startCountdown(SELECTION_DURATION_SECONDS, "select", handleTimeOver);
}

function startCountdown(totalSeconds, mode, onComplete) {
  const seconds = Math.max(0, Math.round(totalSeconds));
  stopCountdown();
  countdownWarningThreshold = mode === "select" ? 3 : 2;
  countdownRemaining = seconds;
  countdownCompleteCallback = typeof onComplete === "function" ? onComplete : null;

  if (countdownCircle) {
    countdownCircle.classList.remove("warning", "mode-select");
    if (mode === "select") {
      countdownCircle.classList.add("mode-select");
    }
  }

  updateCountdownDisplay(countdownRemaining);

  if (seconds === 0) {
    const callback = countdownCompleteCallback;
    countdownCompleteCallback = null;
    if (callback) {
      callback();
    }
    return;
  }

  countdownIntervalId = window.setInterval(() => {
    countdownRemaining -= 1;
    if (countdownRemaining <= 0) {
      const callback = countdownCompleteCallback;
      stopCountdown();
      updateCountdownDisplay(0);
      countdownCompleteCallback = null;
      if (callback) {
        callback();
      }
    } else {
      updateCountdownDisplay(countdownRemaining);
    }
  }, 1000);
}

function stopCountdown() {
  if (countdownIntervalId !== null) {
    window.clearInterval(countdownIntervalId);
    countdownIntervalId = null;
  }
  countdownCompleteCallback = null;
  if (countdownCircle) {
    countdownCircle.classList.remove("warning", "mode-select");
  }
}

function updateCountdownDisplay(value) {
  if (!countdownValueEl) {
    return;
  }

  const displayValue = Math.max(0, Math.floor(value));
  countdownValueEl.textContent = displayValue;

  const shouldWarn = displayValue <= countdownWarningThreshold && displayValue > 0;
  if (countdownCircle) {
    countdownCircle.classList.toggle("warning", shouldWarn);
  }
}

function resetSelectionHistory() {
  playerSelections = [];
  renderSelectionHistory();
}

function renderSelectionHistory() {
  selectionList.innerHTML = "";

  if (playerSelections.length === 0) {
    const placeholder = document.createElement("span");
    placeholder.className = "selection-chip placeholder";
    placeholder.textContent = "Êú™ÈÅ∏Êäû";
    selectionList.appendChild(placeholder);
    return;
  }

  playerSelections.forEach((emoji, index) => {
    const chip = document.createElement("span");
    chip.className = "selection-chip";
    chip.textContent = emoji;
    chip.setAttribute("aria-label", `${index + 1}Áï™ÁõÆ ${emoji}`);
    selectionList.appendChild(chip);
  });
}

function handleIncorrectSelection(selectedEmoji) {
  const button = choiceButtons.find((btn) => btn.dataset.emoji === selectedEmoji);
  if (button) {
    button.disabled = true;
    button.dataset.result = "√ó";
    button.classList.add("choice-fail");
    button.classList.remove("choice-success");
  }

  if (mistakesLeft > 0) {
    mistakesLeft -= 1;
    setFeedback("error");
    setMessage(`√óÔºÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇÔºàÊÆã„Çä„É™„Éà„É©„Ç§${mistakesLeft}ÂõûÔºâ`, "error");
    hideStatusPopup();
    return;
  }

  handleGameOver(selectedEmoji);
}

function handleTimeOver() {
  if (!acceptingGuesses || remainingAnswers.length === 0) {
    return;
  }
  handleGameOver(null, {
    messageOverride: "ÊôÇÈñìÂàá„ÇåÔºÅ„Çø„Ç§„É†„Ç™„Éº„Éê„Éº„Åß„Åô„ÄÇ",
    popupType: "timeout",
    popupMessage: "„Çø„Ç§„É†„Ç™„Éº„Éê„ÉºÔºÅ",
    actions: [
      {
        label: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂",
        className: "restart",
        onClick: () => returnToStartScreen()
      }
    ]
  });
}

function getActiveEmojiPool() {
  const config = DIFFICULTY_CONFIG[selectedDifficulty] || DIFFICULTY_CONFIG.easy;
  return EMOJIS.slice(0, config.size);
}

function renderChoices() {
  choicesContainer.innerHTML = "";
  const pool = getActiveEmojiPool();
  choiceButtons = pool.map((emoji) => {
    const button = document.createElement("button");
    button.type = "button";
    button.className = "choice-btn";
    button.dataset.emoji = emoji;
    button.textContent = emoji;
    button.dataset.result = "";
    button.setAttribute("aria-label", `${emoji} „ÇíÈÅ∏„Å∂`);
    button.disabled = true;
    button.addEventListener("click", () => handleChoice(emoji));
    choicesContainer.appendChild(button);
    return button;
  });
}

function setFeedback(state) {
  const iconEl = document.getElementById("feedback-icon");
  if (!iconEl) {
    return;
  }

  iconEl.textContent = "";
  iconEl.className = "";

  if (state === "success") {
    iconEl.textContent = "‚óé";
    iconEl.classList.add("success");
  } else if (state === "error") {
    iconEl.textContent = "√ó";
    iconEl.classList.add("error");
  }
}

function showStatusPopup(type, text, actions = []) {
  if (!statusPopup || !statusText) {
    return;
  }

  statusPopup.className = "status-popup";
  if (type) {
    statusPopup.classList.add(type);
  }
  statusPopup.classList.remove("hidden");
  statusText.textContent = text;
  statusText.style.animation = "none";
  void statusText.offsetWidth;
  statusText.style.animation = "pop 0.45s ease-out forwards";

  if (statusActions) {
    statusActions.innerHTML = "";
    actions.forEach((action) => {
      const button = document.createElement("button");
      button.type = "button";
      button.className = `popup-btn ${action.className || ""}`.trim();
      button.textContent = action.label;
      button.addEventListener("click", action.onClick);
      statusActions.appendChild(button);
    });
  }
}

function hideStatusPopup() {
  if (!statusPopup) {
    return;
  }
  statusPopup.classList.add("hidden");
  statusPopup.classList.remove("success", "timeout", "ended");
  if (statusActions) {
    statusActions.innerHTML = "";
  }
}

function endGameManually() {
  stopCountdown();
  acceptingGuesses = false;
  setChoicesEnabled(false);
  revealCards();
  setFeedback("neutral");

  const rankInfo = getRankInfo(selectedDifficulty, currentLevel);
  const summary = [
    `${rankInfo.difficultyLabel}Ôºà„Ç´„Éº„Éâ${rankInfo.cardCount}ÊûöÔºö${rankInfo.worldName}Ôºâ`,
    `ÁèæÂú®„ÅÆ„É¨„Éô„É´: Lv${currentLevel}`,
    `Áß∞Âè∑: ${rankInfo.title}`,
    `ÊúÄÈ´ò„Çπ„Ç≥„Ç¢: ${bestScore}`
  ].join("\n");
  setMessage("„Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ„ÅÑ„Å§„Åß„ÇÇÂÜçÊåëÊà¶„Åß„Åç„Åæ„Åô„ÄÇ");
  showStatusPopup("ended", summary, [
    {
      label: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂",
      className: "restart",
      onClick: () => returnToStartScreen()
    },
    {
      label: "ÁµêÊûú„Çí„Ç∑„Çß„Ç¢",
      className: "share",
      onClick: () => shareResult(summary)
    }
  ]);
  restartBtn.classList.remove("hidden");
}

function getRankInfo(difficulty, level) {
  const meta = RANK_TABLE[difficulty] || RANK_TABLE.easy;
  const cardCount = DIFFICULTY_CONFIG[difficulty]?.size || DIFFICULTY_CONFIG.easy.size;
  const titles = meta.titles;
  const index = Math.max(1, Math.min(level, titles.length)) - 1;
  let title = titles[index] || titles[titles.length - 1];
  if (level > titles.length) {
    title = `${title}+`;
  }
  return {
    difficultyLabel: meta.label,
    worldName: meta.world,
    title,
    cardCount
  };
}

function shareResult(summary) {
  const shareText = `Ë®òÊÜ∂„Ç¢„Éâ„Éô„É≥„ÉÅ„É£„Éº„ÅßÊåëÊà¶ÔºÅ\n${summary}\n„ÅÇ„Å™„Åü„ÇÇË©¶„Åó„Å¶„Åø„Å¶„Å≠ÔºÅ`;

  if (typeof navigator !== "undefined" && navigator.share) {
    navigator
      .share({ text: shareText })
      .catch(() => {
        fallbackCopyToClipboard(shareText);
      });
  } else {
    fallbackCopyToClipboard(shareText);
  }
}

function fallbackCopyToClipboard(text) {
  if (typeof navigator === "undefined" || !navigator.clipboard) {
    window.prompt("‰ª•‰∏ã„ÅÆÂÜÖÂÆπ„Çí„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ", text);
    return;
  }

  navigator.clipboard
    .writeText(text)
    .then(() => {
      setMessage("ÁµêÊûú„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ", "success");
    })
    .catch(() => {
      setMessage("„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊâãÂãï„Åß„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", "error");
    });
}

function showStartOverlay() {
  if (!startOverlay) {
    return;
  }
  startOverlay.classList.remove("hidden");
}

function hideStartOverlay() {
  if (!startOverlay) {
    return;
  }
  startOverlay.classList.add("hidden");
}

function returnToStartScreen() {
  stopCountdown();
  acceptingGuesses = false;
  setChoicesEnabled(false);
  showStartOverlay();
  hideStatusPopup();
  restartBtn.classList.add("hidden");
  setMessage("");
  cardList.innerHTML = "";
  resetSelectionHistory();
}

function persistBestScore() {
  try {
    localStorage.setItem(BEST_SCORE_KEY, String(bestScore));
  } catch (error) {
    // localStorage „Åå‰ΩøÁî®„Åß„Åç„Å™„ÅÑÁí∞Â¢É„Åß„ÅØ‰øùÂ≠ò„ÇíË´¶„ÇÅ„Çã
  }
}

// ÂàùÊúüÂåñ
init();
